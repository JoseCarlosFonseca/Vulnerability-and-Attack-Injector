/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package attackinjector;

import java.io.*;
import java.sql.*;
import java.util.Properties;
import java.util.regex.*;
import javax.swing.*;

/**
 *
 * @author ze
 */
public class DatabaseAccess {

    private String LS = System.getProperty("line.separator"); //line terminator of the current system

    // JavaDB example from: /home/ze/glassfish-v2ur2/javadb/demo/programs/simple/SimpleApp.java
    // see   file:///home/ze/Desktop/backup%20portatil/ze/glassfish-v2ur1/javadb/demo/programs/simple/example.html
    /* the default framework is embedded*/
    private String framework = null;
    private String driver = null;
    private String protocol = null;
    private Connection conn = null;
    private Properties props = null;
    private String databaseName = null;

    public DatabaseAccess() {
        this.conn = null;
        this.props = new Properties();

        this.databaseName = "AttackDB";

        //Username and Password of the embedded database
        this.props.put("user", "attackdb");
        this.props.put("password", "attackdb");

        //Put the database in Embedded mode
        this.framework = "embedded";
        this.driver = "org.apache.derby.jdbc.EmbeddedDriver";
        this.protocol = "jdbc:derby:";

        //Put the database in Client/Server mode
        this.framework = "derbyclient";
        this.driver = "org.apache.derby.jdbc.ClientDriver";
        this.protocol = "jdbc:derby://localhost:1527/";
    }

    public DatabaseAccess(Properties DBprops) {
        this.conn = null;
        this.props = new Properties();

        this.databaseName = DBprops.getProperty("databaseName");

        //Username and Password of the embedded database
        this.props.put("user", DBprops.getProperty("user"));
        this.props.put("password", DBprops.getProperty("password"));

        this.framework = DBprops.getProperty("framework");
        this.driver = DBprops.getProperty("driver");
        this.protocol = DBprops.getProperty("protocol");
    }

    public DatabaseAccess(String framework, String driver, String protocol, String databaseName, String username, String password) {
        this.conn = null;
        this.props = new Properties();

        this.databaseName = databaseName;

        //Username and Password of the embedded database
        this.props.put("user", username);
        this.props.put("password", password);

        this.framework = framework;
        this.driver = driver;
        this.protocol = protocol;
    }

    public Connection getConn() {
        return conn;
    }

    public Connection setConn() {
        try {
            /*
            The connection specifies create=true to cause
            the database to be created. To remove the database,
            remove the directory AttackDB and its contents.
            The directory AttackDB will be created under
            the directory that the system property
            derby.system.home points to, or the current
            directory if derby.system.home is not set.
             */

            if (this.databaseName != null) {
                if (conn != null) {
                    if (!conn.isClosed()) {
                        conn.close();
                    }
                }
                conn = DriverManager.getConnection(protocol + this.databaseName + ";create=false", props);

                return conn;
            }
        } catch (Throwable e) {
            System.out.println("exception thrown:");

            if (e instanceof SQLException) {
                printSQLError((SQLException) e);
            } else {
                e.printStackTrace();
            }
        }
        return null;
    }

    public String getDatabaseName() {
        return this.databaseName;
    }

    public void StartDatabase() {
        try {
            /*
            The driver is installed by loading its class.
            In an embedded environment, this will start up Derby, since it is not already running.
             */
            Class.forName(this.driver).newInstance();
        } catch (Throwable e) {
            System.out.println("exception thrown:");

            if (e instanceof SQLException) {
                printSQLError((SQLException) e);
            } else {
                e.printStackTrace();
            }
        }

    }

    public boolean StopDatabase() {
        /*
        In embedded mode, an application should shut down Derby.
        If the application fails to shut down Derby explicitly,
        the Derby does not perform a checkpoint when the JVM shuts down, which means
        that the next connection will be slower.
        Explicitly shutting down Derby with the URL is preferred.
        This style of shutdown will always throw an "exception".
         */
        boolean gotSQLExc = false;

        if (framework.equals("embedded")) {
            try {
//                Code to shut down a specific database looks like this:
//                DriverManager.getConnection("jdbc:derby:MyDbTest;shutdown=true");

//                Code to shut down all databases and the Derby engine looks like this:
                DriverManager.getConnection("jdbc:derby:;shutdown=true");
            } catch (SQLException se) {
                gotSQLExc = true;
            }

        }
        return gotSQLExc;
    }

    public void CreateDatabase() {
        try {
            /*
            The connection specifies create=true to cause
            the database to be created. To remove the database,
            remove the directory AttackDB and its contents.
            The directory AttackDB will be created under
            the directory that the system property
            derby.system.home points to, or the current
            directory if derby.system.home is not set.
             */
            if (this.databaseName != null) {
                if (conn != null) {
                    if (!conn.isClosed()) {
                        conn.close();
                    }
                }
                this.conn = DriverManager.getConnection(protocol + this.databaseName + ";create=true", this.props);

                System.out.println("Connected to and created database " + this.databaseName);

                conn.setAutoCommit(false);

                /*
                Creating a statement lets us issue commands against
                the connection.
                 */
                Statement s = conn.createStatement();
                try {
                    s.execute("CREATE SCHEMA AUTHORIZATION " + this.props.getProperty("user")); //name of the schema of the database

                } catch (Throwable e) {
                    System.out.println("exception thrown:");

                    if (e instanceof SQLException) {
                        printSQLError((SQLException) e);
                    } else {
                        e.printStackTrace();
                    }

                }

                /*
                We create the database tables and populate data.
                 */

                String line = null;
                int LineLength = 0, Semicolon = 0;
                //Ze using the StringBuffer is much more quick than any other way!!!!!
                StringBuffer buf = new StringBuffer();
                try {
                    // Open the file that is the first
                    // command line parameter
                    BufferedReader in = new BufferedReader(new FileReader("database.sql"));
                    while ((line = in.readLine()) != null) {
                        Semicolon = line.lastIndexOf(";");
                        LineLength = line.length();
                        if ((Semicolon == LineLength - 1) & (Semicolon != -1)) {
                            line = line.substring(0, LineLength - 1);
                            buf.append(line);
                            try {
                                s.execute(buf.toString());
                            } catch (Throwable e) {
                                System.out.println("exception thrown:");

                                if (e instanceof SQLException) {
                                    printSQLError((SQLException) e);
                                } else {
                                    e.printStackTrace();
                                }

                            }
                            buf.delete(0, buf.length());
                        } else {
                            buf.append(line + LS);
                        }
                    }
                    in.close();
                    conn.commit();
                    System.out.println("Created tables");
                } catch (Exception e) {
                    System.err.println("File input error");
                }

                s.close();
                conn.close();
            }
        } catch (Throwable e) {
            System.out.println("exception thrown:");

            if (e instanceof SQLException) {
                printSQLError((SQLException) e);
            } else {
                e.printStackTrace();
            }

        }

    }

    public String[] ReadTargetPHPFileData() {
        String[] FaultTypeOperators = null;

        int count = 0;
        Statement s = null;
        ResultSet rs = null;

        // Adapted from http://developers.sun.com/docs/javadb/10.2.2/ref/rrefclob.html
        try {
            if ((conn = setConn()) != null) {
                System.out.println("Connected to database " + getDatabaseName());
            } else {
                throw new Exception("Not connected to database " + getDatabaseName());
            }

            conn.setAutoCommit(false);


            // Test to see if the Target PHP file is already in the DB
            s = conn.createStatement();
            rs = s.executeQuery("SELECT COUNT(*) FROM TARGET_PHP_FILES"); // get the result

            rs.next();
            count = rs.getInt(1);
            rs.close();
            s.close();

            FaultTypeOperators = new String[count + 1];
            FaultTypeOperators[0] = "null";

            // Test to see if the Target PHP file is already in the DB
            s = conn.createStatement();
            rs = s.executeQuery("SELECT PATH FROM TARGET_PHP_FILES"); // get the result

            while (rs.next()) {
                // Open matches log file.
                FaultTypeOperators[rs.getRow()] = rs.getString(1);
            }
            rs.close();
            conn.commit();
            conn.close();

        } catch (Throwable e) {
            System.out.println("exception thrown:");

            if (e instanceof SQLException) {
                printSQLError((SQLException) e);
            } else {
                e.printStackTrace();
            }
        }
        return FaultTypeOperators;
    }

    public String[] ReadVulnerabilityData(String TargetPHPFileSelectedComboBox) {
        String[] VulnerabilityData = null;

        int count = 0;
        PreparedStatement ps = null;
        ResultSet rs = null;

        // Adapted from http://developers.sun.com/docs/javadb/10.2.2/ref/rrefclob.html
        try {
            if ((conn = setConn()) != null) {
                System.out.println("Connected to database " + getDatabaseName());
            } else {
                throw new Exception("Not connected to database " + getDatabaseName());
            }

            conn.setAutoCommit(false);


            // Test to see if the Target PHP file is already in the DB
            ps = conn.prepareStatement("SELECT COUNT(*) FROM VULNERABILITY_INJECTION_RESULTS,TARGET_PHP_FILES WHERE VULNERABILITY_INJECTION_RESULTS.TARGET_PHP_FILE=TARGET_PHP_FILES.ID AND TARGET_PHP_FILES.PATH=?"); // get the result

            ps.setString(1, TargetPHPFileSelectedComboBox);
            rs = ps.executeQuery(); // get the result

            rs.next();
            count = rs.getInt(1);
            rs.close();
            ps.close();

            VulnerabilityData = new String[count + 1];
            VulnerabilityData[0] = "null";

            // Test to see if the Target PHP file is already in the DB
            ps = conn.prepareStatement("SELECT VULNERABILITY_INJECTION_RESULTS.DIFF_TEXT FROM VULNERABILITY_INJECTION_RESULTS,TARGET_PHP_FILES WHERE VULNERABILITY_INJECTION_RESULTS.TARGET_PHP_FILE=TARGET_PHP_FILES.ID AND TARGET_PHP_FILES.PATH=?"); // get the result

            ps.setString(1, TargetPHPFileSelectedComboBox);
            rs = ps.executeQuery(); // get the result

            while (rs.next()) {
                // Open matches log file.
                VulnerabilityData[rs.getRow()] = rs.getString(1);
            }
            rs.close();
            ps.close();
            conn.commit();
            conn.close();

        } catch (Throwable e) {
            System.out.println("exception thrown:");

            if (e instanceof SQLException) {
                printSQLError((SQLException) e);
            } else {
                e.printStackTrace();
            }
        }
        return VulnerabilityData;
    }

    public String[] ReadTargetPHPFileSQLVariablesData() {
        String[] FaultTypeOperators = null;

        int count = 0;
        Statement s = null;
        ResultSet rs = null;

        // Adapted from http://developers.sun.com/docs/javadb/10.2.2/ref/rrefclob.html
        try {
            if ((conn = setConn()) != null) {
                System.out.println("Connected to database " + getDatabaseName());
            } else {
                throw new Exception("Not connected to database " + getDatabaseName());
            }

            conn.setAutoCommit(false);


            // Test to see if the Target PHP file is already in the DB
            s = conn.createStatement();
            rs = s.executeQuery("SELECT COUNT(*) FROM TARGET_PHP_FILES_SQL_VARIABLES"); // get the result

            rs.next();
            count = rs.getInt(1);
            rs.close();
            s.close();

            FaultTypeOperators = new String[count + 1];
            FaultTypeOperators[0] = "null";

            // Test to see if the Target PHP file is already in the DB
            s = conn.createStatement();
            rs = s.executeQuery("SELECT TARGET_VARIABLE_NAME FROM TARGET_PHP_FILES_SQL_VARIABLES"); // get the result

            while (rs.next()) {
                // Open matches log file.
                FaultTypeOperators[rs.getRow()] = rs.getString(1);
            }
            rs.close();
            conn.commit();
            conn.close();

        } catch (Throwable e) {
            System.out.println("exception thrown:");

            if (e instanceof SQLException) {
                printSQLError((SQLException) e);
            } else {
                e.printStackTrace();
            }
        }
        return FaultTypeOperators;
    }

    public String[] ReadAttackPayloadData() {
        String[] FaultTypeOperators = null;

        int count = 0;
        Statement s = null;
        ResultSet rs = null;

        // Adapted from http://developers.sun.com/docs/javadb/10.2.2/ref/rrefclob.html
        try {
            if ((conn = setConn()) != null) {
                System.out.println("Connected to database " + getDatabaseName());
            } else {
                throw new Exception("Not connected to database " + getDatabaseName());
            }

            conn.setAutoCommit(false);


            // Test to see if the Target PHP file is already in the DB
            s = conn.createStatement();
            rs = s.executeQuery("SELECT COUNT(*) FROM PAYLOADS"); // get the result

            rs.next();
            count = rs.getInt(1);
            rs.close();
            s.close();

            FaultTypeOperators = new String[count + 1];
            FaultTypeOperators[0] = "null";

            // Test to see if the Target PHP file is already in the DB
            s = conn.createStatement();
            rs = s.executeQuery("SELECT PAYLOAD FROM PAYLOADS"); // get the result

            while (rs.next()) {
                // Open matches log file.
                FaultTypeOperators[rs.getRow()] = rs.getString(1);
            }
            rs.close();
            conn.commit();
            conn.close();

        } catch (Throwable e) {
            System.out.println("exception thrown:");

            if (e instanceof SQLException) {
                printSQLError((SQLException) e);
            } else {
                e.printStackTrace();
            }
        }
        return FaultTypeOperators;
    }

    public String[] ReadPayloadHTTPData() {
        String[] FaultTypeOperators = null;

        int count = 0;
        Statement s = null;
        ResultSet rs = null;

        // Adapted from http://developers.sun.com/docs/javadb/10.2.2/ref/rrefclob.html
        try {
            if ((conn = setConn()) != null) {
                System.out.println("Connected to database " + getDatabaseName());
            } else {
                throw new Exception("Not connected to database " + getDatabaseName());
            }

            conn.setAutoCommit(false);


            // Test to see if the Target PHP file is already in the DB
            s = conn.createStatement();
            rs = s.executeQuery("SELECT COUNT(*) FROM TARGET_PHP_FILES_RUNS_FUNCTIONS"); // get the result

            rs.next();
            count = rs.getInt(1);
            rs.close();
            s.close();

            FaultTypeOperators = new String[count + 1];
            FaultTypeOperators[0] = "null";

            // Test to see if the Target PHP file is already in the DB
            s = conn.createStatement();
            rs = s.executeQuery("SELECT ID FROM TARGET_PHP_FILES_RUNS_FUNCTIONS"); // get the result

            while (rs.next()) {
                // Open matches log file.
                FaultTypeOperators[rs.getRow()] = rs.getString(1);
            }
            rs.close();
            conn.commit();
            conn.close();

        } catch (Throwable e) {
            System.out.println("exception thrown:");

            if (e instanceof SQLException) {
                printSQLError((SQLException) e);
            } else {
                e.printStackTrace();
            }
        }
        return FaultTypeOperators;
    }
    // ReadFile2DB Read a file and stores it in the database

    public int ReadFile2DB(File TargetFile, String host, String hostPath, String FileURL, DatabaseAccess JavaDBAccess, boolean ConfirmDialog) {
        PreparedStatement ps = null;
        int TARGET_PHP_FILES_ID = 0, TARGET_PHP_WEB_APPLICATION_ID = -1, count = 0, fileLength = 0;
        String Line = "", PHPFileTextClean = "";
        ResultSet rs = null;
        // Adapted from http://developers.sun.com/docs/javadb/10.2.2/ref/rrefclob.html
        try {
            conn.setAutoCommit(false);

            if (TargetFile.getName().toLowerCase().endsWith(".php")) {//only works with .php files
                // Test to see if the TARGET_PHP_WEB_APPLICATIONS is already in the DB

                ps = conn.prepareStatement("SELECT COUNT(*) FROM TARGET_PHP_WEB_APPLICATIONS WHERE HOST=? AND HOST_PATH=?");
                ps.setString(1, host);
                ps.setString(2, hostPath);

                rs = ps.executeQuery(); // get the result

                rs.next();
                count = rs.getInt(1);
                rs.close();
                ps.close();

                if (count == 0) {// Inserts the Target PHP file

                    ps = conn.prepareStatement("INSERT INTO TARGET_PHP_WEB_APPLICATIONS (ID, HOST, HOST_PATH, ACTIVE) VALUES (DEFAULT,?,?,'Y')", Statement.RETURN_GENERATED_KEYS);
                    ps.setString(1, host);
                    ps.setString(2, hostPath);
                    ps.execute();

                    rs = ps.getGeneratedKeys(); // get the auto increment column key value

                    rs.next();
                    TARGET_PHP_WEB_APPLICATION_ID = rs.getInt(1);
                    rs.close();

                } else {// gets the primary key

                    ps = conn.prepareStatement("SELECT ID FROM TARGET_PHP_WEB_APPLICATIONS WHERE HOST=? AND HOST_PATH=?");
                    ps.setString(1, host);
                    ps.setString(2, hostPath);

                    rs = ps.executeQuery(); // get the result

                    rs.next();
                    TARGET_PHP_WEB_APPLICATION_ID = rs.getInt(1);
                    rs.close();
                    ps.close();
                }


                // Test to see if the Target PHP file is already in the DB
                ps = conn.prepareStatement("SELECT COUNT(*) FROM TARGET_PHP_FILES WHERE PATH=?");
                ps.setString(1, TargetFile.getAbsolutePath());

                rs = ps.executeQuery(); // get the result

                rs.next();
                count = rs.getInt(1);
                rs.close();
                ps.close();

                if (count == 0) {// Inserts the Target PHP file

                    fileLength = (int) TargetFile.length();
                    // - first, create an input stream
                    InputStream fin = new FileInputStream(TargetFile);

                    // Start a transaction by inserting a record in the TARGET_PHP_FILES table
                    ps = conn.prepareStatement("INSERT INTO TARGET_PHP_FILES (ID, TARGET_PHP_WEB_APPLICATION, NAME, URL, PATH, TEXT, CLEANED_TEXT, ACTIVE) VALUES(DEFAULT,?,?,?,?,?,?,'Y')", Statement.RETURN_GENERATED_KEYS);
                    ps.setInt(1, TARGET_PHP_WEB_APPLICATION_ID);
                    ps.setString(2, TargetFile.getName());
                    ps.setString(3, FileURL);
                    ps.setString(4, TargetFile.getAbsolutePath());
                    // - set the value of the input parameter to the input stream
                    ps.setAsciiStream(5, fin, fileLength);
                    ps.setNull(6, java.sql.Types.CLOB);//CLEANED_TEXT

                    ps.execute();

                    rs = ps.getGeneratedKeys(); // get the auto increment column key value

                    rs.next();
                    TARGET_PHP_FILES_ID = rs.getInt(1);
                    System.out.println("Chave usada: " + TARGET_PHP_FILES_ID);
                    rs.close();
                    //Cleans the PHP file text 
                    PHPFileTextClean = CleanPHPFile(TARGET_PHP_FILES_ID, JavaDBAccess);
                } else {// The file already exists in the DB

                    int n = JOptionPane.YES_OPTION;
                    if (ConfirmDialog) {
                        n = 0;
                        n = JOptionPane.showConfirmDialog(new JFrame(), "The file\n" + TargetFile.getAbsolutePath() + "\nalready exists in the database.\nIf you decide to update the file all the results based on it will be deleted\nDo you want to update the file?", "Attention!", JOptionPane.ERROR_MESSAGE, JOptionPane.YES_NO_OPTION);
                    }
                    if (n == JOptionPane.YES_OPTION) {//updates the file

                        // Clean previous vulnerability injections in the same file
                        System.out.println(TargetFile.getAbsolutePath());
                        ps = conn.prepareStatement("DELETE FROM VULNERABILITY_INJECTION_RESULTS WHERE ID IN (SELECT VULNERABILITY_INJECTION_RESULTS.ID FROM VULNERABILITY_INJECTION_RESULTS, TARGET_PHP_FILES WHERE TARGET_PHP_FILE=TARGET_PHP_FILES.ID AND TARGET_PHP_FILES.PATH=?)");
                        ps.setString(1, TargetFile.getAbsolutePath());
                        ps.execute();
                        conn.commit();

                        // Updates the Target PHP file
                        ps = conn.prepareStatement("SELECT ID FROM TARGET_PHP_FILES WHERE PATH=?");
                        ps.setString(1, TargetFile.getAbsolutePath());

                        rs = ps.executeQuery(); // get the result

                        rs.next();
                        TARGET_PHP_FILES_ID = rs.getInt(1);
                        rs.close();

                        fileLength = (int) TargetFile.length();
                        // - first, create an input stream
                        InputStream fin = new FileInputStream(TargetFile);

                        // Start a transaction by inserting a record in the TARGET_PHP_FILES table
                        ps = conn.prepareStatement("UPDATE TARGET_PHP_FILES SET TEXT=? WHERE ID=?");
                        // - set the value of the input parameter to the input stream
                        ps.setAsciiStream(1, fin, fileLength);
                        ps.setInt(2, TARGET_PHP_FILES_ID);
                        ps.execute();
                        rs.close();
                        //Cleans the PHP file text 
                        PHPFileTextClean = CleanPHPFile(TARGET_PHP_FILES_ID, JavaDBAccess);
                    }
                }
                conn.commit();
                ps.close();
            }
        } catch (Throwable e) {
            System.out.println("Errors in ReadFile2DB!");
            System.out.println("exception thrown:");

            if (e instanceof SQLException) {
                printSQLError((SQLException) e);
            } else {
                e.printStackTrace();
            }
        }
        return TARGET_PHP_FILES_ID;
    }

    public void PHPFileIncludes(int TARGET_PHP_FILES_ID, DatabaseAccess JavaDBAccess, PHPFileOperations PHPFile) {
        PreparedStatement ps = null, psUpdate = null;
        ResultSet rs = null;
        String PHPFileTextClean = "";

        String RegExpText = "", host = "", HostPath = "";
        Boolean CaseSensitiveOption = false;
        Matcher existMatch = null;
        Pattern p = null;
        int existMatchStart = 0, existMatchEnd = 0, INCLUDED_TARGET_PHP_FILES_ID;
        int VariableLocationInsideString = -1;
        File f;
        String HTTP_REQUEST_PATH = "", TARGET_PHP_FILES_PATH = "";
        int pos, count;

        try {

            ps = conn.prepareStatement("SELECT CLEANED_TEXT, PATH, HOST, HOST_PATH FROM TARGET_PHP_FILES, TARGET_PHP_WEB_APPLICATIONS WHERE TARGET_PHP_FILES.TARGET_PHP_WEB_APPLICATION=TARGET_PHP_WEB_APPLICATIONS.ID AND TARGET_PHP_FILES.ID=?");
            ps.setInt(1, TARGET_PHP_FILES_ID);
            rs = ps.executeQuery();

            rs.next();
            PHPFileTextClean = rs.getString("CLEANED_TEXT");
            TARGET_PHP_FILES_PATH = rs.getString("PATH");
            host = rs.getString("HOST");
            HostPath = rs.getString("HOST_PATH");
            rs.close();
            ps.close();

            pos = TARGET_PHP_FILES_PATH.lastIndexOf(File.separator);
            TARGET_PHP_FILES_PATH = TARGET_PHP_FILES_PATH.substring(0, pos);


            CaseSensitiveOption = false;
            RegExpText = "(\\brequire\\b|\\brequire_once\\b|\\binclude\\b|\\binclude_once\\b)(\\s+|\\()\"";
            if (CaseSensitiveOption) {
                p = Pattern.compile(RegExpText);
            } else {
                p = Pattern.compile(RegExpText, Pattern.CASE_INSENSITIVE);
            }

            existMatch = p.matcher(PHPFileTextClean);

            while (existMatch.find()) {
                existMatchStart = existMatch.start();
                existMatchEnd = existMatch.end();

                VariableLocationInsideString = PHPFile.TextInsidePHPString(PHPFileTextClean, existMatchStart);
                if (VariableLocationInsideString == -1) {
                    pos = PHPFileTextClean.indexOf("\"", existMatchEnd);
                    HTTP_REQUEST_PATH = PHPFileTextClean.substring(existMatchEnd, pos);
                    if (!HTTP_REQUEST_PATH.contains(TARGET_PHP_FILES_PATH)) {
                        HTTP_REQUEST_PATH = TARGET_PHP_FILES_PATH + File.separator + HTTP_REQUEST_PATH;
                    }
                    f = new File(HTTP_REQUEST_PATH);

                    ps = conn.prepareStatement("SELECT COUNT(*) FROM TARGET_PHP_FILES WHERE PATH=?");
                    ps.setString(1, HTTP_REQUEST_PATH);
                    rs = ps.executeQuery();

                    rs.next();
                    count = rs.getInt(1);
                    rs.close();
                    ps.close();

                    if (count == 0) {
                        HTTP_REQUEST_PATH = HTTP_REQUEST_PATH.substring(HostPath.length() - 1, HTTP_REQUEST_PATH.lastIndexOf(File.separator) + 1);
                        if ((INCLUDED_TARGET_PHP_FILES_ID = ReadFile2DB(f, host, HostPath, HTTP_REQUEST_PATH, JavaDBAccess, false)) > 0) {
                            ps = conn.prepareStatement("INSERT INTO TARGET_PHP_FILES_INCLUDES (TARGET_PHP_FILE_MASTER,TARGET_PHP_FILE_INCLUDED) VALUES (?,?)");
                            ps.setInt(1, TARGET_PHP_FILES_ID);
                            ps.setInt(2, INCLUDED_TARGET_PHP_FILES_ID);
                            ps.executeUpdate();
                            ps.close();
                        }
                    }
                }
            }

        } catch (Throwable e) {
            System.out.println("Errors in ParsePHPFile!");
            System.out.println("exception thrown:");

            if (e instanceof SQLException) {
                JavaDBAccess.printSQLError((SQLException) e);
            } else {
                e.printStackTrace();
            }
        }
    }
    //Cleans the PHP file text by removing the HTML and PHP comments

    public String CleanPHPFile(int TARGET_PHP_FILES_ID, DatabaseAccess JavaDBAccess) {
        PreparedStatement ps = null, psUpdate = null;
        ResultSet rs = null;
        String PHPFileText = "", PHPFileTextClean = "";
        int PHPFileTextIndex = 0;
        int StartIndexPHPCode = 0, EndIndexPHPCode = 0, StartIndexPHPMultipleLineComment = 0, EndIndexPHPMultipleLineComment = 0, StartIndexPHPSingleLineComment = 0, StartIndexPHPSingleLineComment2 = 0, EndIndexPHPSingleLineComment = 0, EndIndexPHPSingleLineComment_n = 0, EndIndexPHPSingleLineComment_r = 0;
        int StartIndexHTMLCode = 0, EndIndexHTMLCode = 0, StartIndexHTMLComment = 0, EndIndexHTMLComment = 0;
        int StartIndexSingleQuoteString = 0, EndIndexSingleQuoteString = 0, StartIndexDoubleQuoteString = 0, EndIndexDoubleQuoteString = 0;
        int aux = 0, count = 0;

        try {

            ps = conn.prepareStatement("SELECT TEXT FROM TARGET_PHP_FILES WHERE ID=?");
            ps.setInt(1, TARGET_PHP_FILES_ID);
            rs = ps.executeQuery();

            rs.next();
            PHPFileText = rs.getString("TEXT");
            rs.close();


            //Process the content of the PHP file
            PHPFileTextClean = PHPFileText;
            PHPFileTextIndex = 0;

            while (PHPFileTextIndex < PHPFileText.length()) {
                //The current location is HTML code
                StartIndexPHPCode = PHPFileText.indexOf("<?", PHPFileTextIndex);//start of a PHP block of code

                StartIndexHTMLComment = PHPFileText.indexOf("<!--", PHPFileTextIndex);//start of a HTML comment

                StartIndexDoubleQuoteString = PHPFileText.indexOf("\"", PHPFileTextIndex);//start of a double quote HTML string

                StartIndexSingleQuoteString = PHPFileText.indexOf("'", PHPFileTextIndex);//start of a single quote HTML string

                if (StartIndexPHPCode == -1 & StartIndexHTMLComment == -1 & StartIndexDoubleQuoteString == -1 & StartIndexSingleQuoteString == -1) {
                    break;
                }

                //start of a PHP block of code
                if (StartIndexPHPCode >= 0 &
                        ((StartIndexPHPCode < StartIndexHTMLComment) | (StartIndexHTMLComment == -1)) &
                        ((StartIndexPHPCode < StartIndexDoubleQuoteString) | (StartIndexDoubleQuoteString == -1)) &
                        ((StartIndexPHPCode < StartIndexSingleQuoteString) | (StartIndexSingleQuoteString == -1))) {

                    //Clean the PHP comment information
                    for (int i = PHPFileTextIndex; i < StartIndexPHPCode; i++) {
                        if (PHPFileTextClean.charAt(i) != 10 & PHPFileTextClean.charAt(i) != 13) {
                            PHPFileTextClean = PHPFileTextClean.substring(0, i) + " " + PHPFileTextClean.substring(i + 1);
                        }
                    }

                    PHPFileTextIndex = StartIndexPHPCode;
                    while (PHPFileTextIndex < PHPFileText.length()) {
                        EndIndexPHPCode = PHPFileText.indexOf("?>", PHPFileTextIndex);//end of a PHP block of code

                        StartIndexPHPMultipleLineComment = PHPFileText.indexOf("/*", PHPFileTextIndex);//start of a multiple line PHP comment

                        StartIndexPHPSingleLineComment = PHPFileText.indexOf("//", PHPFileTextIndex);//start of a single line PHP comment

                        StartIndexPHPSingleLineComment2 = PHPFileText.indexOf("#", PHPFileTextIndex);//start of a single line PHP comment

                        if ((StartIndexPHPSingleLineComment2 < StartIndexPHPSingleLineComment && StartIndexPHPSingleLineComment2 != -1) || (StartIndexPHPSingleLineComment == -1)) {
                            StartIndexPHPSingleLineComment = StartIndexPHPSingleLineComment2;
                        }
                        StartIndexDoubleQuoteString = PHPFileText.indexOf("\"", PHPFileTextIndex);//start of a double quote PHP string

                        StartIndexSingleQuoteString = PHPFileText.indexOf("'", PHPFileTextIndex);//start of a single quote PHP string

                        if (EndIndexPHPCode == -1 & StartIndexPHPMultipleLineComment == -1 & StartIndexPHPSingleLineComment == -1 & StartIndexDoubleQuoteString == -1 & StartIndexSingleQuoteString == -1) {
                            break;
                        }
                        //end of a PHP block of code
                        if (EndIndexPHPCode >= 0 &
                                ((EndIndexPHPCode < StartIndexPHPMultipleLineComment) | (StartIndexPHPMultipleLineComment == -1)) &
                                ((EndIndexPHPCode < StartIndexPHPSingleLineComment) | (StartIndexPHPSingleLineComment == -1)) &
                                ((EndIndexPHPCode < StartIndexDoubleQuoteString) | (StartIndexDoubleQuoteString == -1)) &
                                ((EndIndexPHPCode < StartIndexSingleQuoteString) | (StartIndexSingleQuoteString == -1))) {
                            if (PHPFileText.substring(StartIndexPHPCode, StartIndexPHPCode + 5).toLowerCase().contentEquals("<?php")) {
                                PHPFileTextClean = PHPFileTextClean.substring(0, StartIndexPHPCode) + "     " + PHPFileTextClean.substring(StartIndexPHPCode + 5);
                                StartIndexPHPCode += 5;
                            } else {
                                PHPFileTextClean = PHPFileTextClean.substring(0, StartIndexPHPCode) + "  " + PHPFileTextClean.substring(StartIndexPHPCode + 2);
                                StartIndexPHPCode += 2;
                            }
                            PHPFileTextClean = PHPFileTextClean.substring(0, EndIndexPHPCode) + "  " + PHPFileTextClean.substring(EndIndexPHPCode + 2);
                            PHPFileTextIndex = EndIndexPHPCode + 2;
                            break;

                        //start of a multiple line PHP comment
                        } else if (StartIndexPHPMultipleLineComment >= 0 &
                                ((StartIndexPHPMultipleLineComment < StartIndexPHPSingleLineComment) | (StartIndexPHPSingleLineComment == -1)) &
                                ((StartIndexPHPMultipleLineComment < StartIndexDoubleQuoteString) | (StartIndexDoubleQuoteString == -1)) &
                                ((StartIndexPHPMultipleLineComment < StartIndexSingleQuoteString) | (StartIndexSingleQuoteString == -1))) {
                            //Search for the end of the double line PHP comment
                            EndIndexPHPMultipleLineComment = PHPFileText.indexOf("*/", StartIndexPHPMultipleLineComment);//end of a multiple line PHP comment
                            //Clean the PHP comment information

                            for (int i = StartIndexPHPMultipleLineComment; i < EndIndexPHPMultipleLineComment + 2; i++) {
                                if (PHPFileTextClean.charAt(i) != 10 & PHPFileTextClean.charAt(i) != 13) {
                                    PHPFileTextClean = PHPFileTextClean.substring(0, i) + " " + PHPFileTextClean.substring(i + 1);
                                }
                            }
                            PHPFileTextIndex = EndIndexPHPMultipleLineComment + 2;

                        //start of a single line PHP comment
                        } else if (StartIndexPHPSingleLineComment >= 0 &
                                ((StartIndexPHPSingleLineComment < StartIndexDoubleQuoteString) | (StartIndexDoubleQuoteString == -1)) &
                                ((StartIndexPHPSingleLineComment < StartIndexSingleQuoteString) | (StartIndexSingleQuoteString == -1))) {

                            //Search for the end of the single line PHP comment
                            EndIndexPHPSingleLineComment_r = PHPFileText.indexOf("\r", StartIndexPHPSingleLineComment);//end of a single line PHP comment

                            EndIndexPHPSingleLineComment_n = PHPFileText.indexOf("\n", StartIndexPHPSingleLineComment);//end of a single line PHP comment

                            if (EndIndexPHPSingleLineComment_r == EndIndexPHPSingleLineComment_n + 1) {
                                EndIndexPHPSingleLineComment = EndIndexPHPSingleLineComment_r;
                            } else if ((EndIndexPHPSingleLineComment_r < EndIndexPHPSingleLineComment_n) & (EndIndexPHPSingleLineComment_r >= 0 & EndIndexPHPSingleLineComment_n >= 0)) {
                                EndIndexPHPSingleLineComment = EndIndexPHPSingleLineComment_r;
                            } else if ((EndIndexPHPSingleLineComment_n < EndIndexPHPSingleLineComment_r) & (EndIndexPHPSingleLineComment_r >= 0 & EndIndexPHPSingleLineComment_n >= 0)) {
                                EndIndexPHPSingleLineComment = EndIndexPHPSingleLineComment_n;
                            } else if (EndIndexPHPSingleLineComment_n == -1 & EndIndexPHPSingleLineComment_r >= 0) {
                                EndIndexPHPSingleLineComment = EndIndexPHPSingleLineComment_r;
                            } else if (EndIndexPHPSingleLineComment_r == -1 & EndIndexPHPSingleLineComment_n >= 0) {
                                EndIndexPHPSingleLineComment = EndIndexPHPSingleLineComment_n;
                            }
                            //Clean the PHP comment information
                            for (int i = StartIndexPHPSingleLineComment; i < EndIndexPHPSingleLineComment; i++) {
                                if (PHPFileTextClean.charAt(i) != 10 & PHPFileTextClean.charAt(i) != 13) {
                                    PHPFileTextClean = PHPFileTextClean.substring(0, i) + " " + PHPFileTextClean.substring(i + 1);
                                }
                            }
                            PHPFileTextIndex = EndIndexPHPSingleLineComment + 1;
                            if (EndIndexPHPSingleLineComment_r == EndIndexPHPSingleLineComment_n + 1) {
                                PHPFileTextIndex++;
                            }

                        //start of a double quote PHP string
                        } else if (StartIndexDoubleQuoteString >= 0 &
                                (StartIndexDoubleQuoteString < StartIndexSingleQuoteString) | (StartIndexSingleQuoteString == -1)) {
                            //Search for the end of the double quote PHP string
                            EndIndexDoubleQuoteString = StartIndexDoubleQuoteString;
                            while (true) {
                                EndIndexDoubleQuoteString = PHPFileText.indexOf("\"", EndIndexDoubleQuoteString + 1);//end of a double quote PHP string

                                if (PHPFileText.charAt(EndIndexDoubleQuoteString - 1) != '\\') {//the \" is a escaped double quote and must be avoided

                                    break;
                                }
                                EndIndexDoubleQuoteString++;
                            }
                            PHPFileTextIndex = EndIndexDoubleQuoteString + 1;

                        //start of a single quote PHP string
                        } else {
                            //Search for the end of the single quote PHP string
                            EndIndexSingleQuoteString = StartIndexSingleQuoteString;
                            aux = EndIndexSingleQuoteString;
                            while (true) {
                                EndIndexSingleQuoteString = PHPFileText.indexOf("'", EndIndexSingleQuoteString + 1);//end of a single quote PHP string

                                count = 0;
                                for (int i = EndIndexSingleQuoteString - 1; i > aux; i--) {//one \ is escaped by another \, so we have to avoid pairs of \
                                    if (PHPFileText.charAt(i) != '\\') {//the \' is a escaped single quote and must be avoided

                                        break;
                                    }
                                    count++;
                                }
                                count = count % 2;//mod (remainder from integer division)
//                                if (PHPFileText.charAt(EndIndexSingleQuoteString - 1) != '\\') {//the \' is a escaped single quote and must be avoided

                                if (count == 0) {//the \' is a escaped single quote and must be avoided

                                    break;
                                }
                                aux = EndIndexSingleQuoteString;
                                EndIndexSingleQuoteString++;
                            }
                            PHPFileTextIndex = EndIndexSingleQuoteString + 1;
                        }
                    }

                //It is an HTML block
                //start of a HTML comment
                } else if (StartIndexHTMLComment >= 0 &
                        ((StartIndexHTMLComment < StartIndexDoubleQuoteString) | (StartIndexDoubleQuoteString == -1)) &
                        ((StartIndexHTMLComment < StartIndexSingleQuoteString) | (StartIndexSingleQuoteString == -1))) {
                    //Clean the HTML comment information
                    //Search for the end of the comment
                    EndIndexHTMLComment = PHPFileText.indexOf("-->", StartIndexHTMLComment);//end of the HTML comment
                    //Clean the HTML information till the end of the comment information

                    for (int i = PHPFileTextIndex; i < EndIndexHTMLComment + 3; i++) {
                        if (PHPFileTextClean.charAt(i) != 10 & PHPFileTextClean.charAt(i) != 13) {
                            PHPFileTextClean = PHPFileTextClean.substring(0, i) + " " + PHPFileTextClean.substring(i + 1);
                        }
                    }
                    PHPFileTextIndex = EndIndexHTMLComment + 3;

                //start of a double quote HTML string
                } else if (StartIndexDoubleQuoteString >= 0 &
                        ((StartIndexDoubleQuoteString < StartIndexSingleQuoteString) | (StartIndexSingleQuoteString == -1))) {
                    //Search for the end of the double quote HTML string
                    EndIndexDoubleQuoteString = PHPFileText.indexOf("\"", StartIndexDoubleQuoteString);//end of a double quote HTML string
                    //Clean the HTML information till the end of the double quote HTML string

                    for (int i = PHPFileTextIndex; i < EndIndexDoubleQuoteString + 1; i++) {
                        if (PHPFileTextClean.charAt(i) != 10 & PHPFileTextClean.charAt(i) != 13) {
                            PHPFileTextClean = PHPFileTextClean.substring(0, i) + " " + PHPFileTextClean.substring(i + 1);
                        }
                    }
                    PHPFileTextIndex = EndIndexDoubleQuoteString + 1;

                //start of a single quote HTML string
                } else {
                    //Search for the end of the single quote HTML string
                    EndIndexSingleQuoteString = PHPFileText.indexOf("'", StartIndexSingleQuoteString);//end of a single quote HTML string
                    //Clean the HTML information till the end of the single quote HTML string

                    for (int i = PHPFileTextIndex; i < EndIndexSingleQuoteString + 1; i++) {
                        if (PHPFileTextClean.charAt(i) != 10 & PHPFileTextClean.charAt(i) != 13) {
                            PHPFileTextClean = PHPFileTextClean.substring(0, i) + " " + PHPFileTextClean.substring(i + 1);
                        }
                    }
                    PHPFileTextIndex = EndIndexSingleQuoteString + 1;
                }
            }
            psUpdate = conn.prepareStatement("UPDATE TARGET_PHP_FILES SET CLEANED_TEXT=? WHERE ID=?");
            psUpdate.setString(1, PHPFileTextClean);
            psUpdate.setInt(2, TARGET_PHP_FILES_ID);
            psUpdate.executeUpdate();
            psUpdate.close();

        } catch (Throwable e) {
            System.out.println("Errors in ParsePHPFile!");
            System.out.println("exception thrown:");

            if (e instanceof SQLException) {
                JavaDBAccess.printSQLError((SQLException) e);
            } else {
                e.printStackTrace();
            }
        }
        return PHPFileTextClean;
    }

    public String ShowTable(String TableName) {
        String showtableOutput = null;
        try {
            /*
            The connection specifies create=true to cause
            the database to be created. To remove the database,
            remove the directory AttackDB and its contents.
            The directory AttackDB will be created under
            the directory that the system property
            derby.system.home points to, or the current
            directory if derby.system.home is not set.
             */
            if ((conn = setConn()) != null) {
                System.out.println("Connected to database " + getDatabaseName());
            } else {
                throw new Exception("Not connected to database " + getDatabaseName());
            }

            conn.setAutoCommit(false);

            /*
            Creating a statement lets us issue commands against
            the connection.
             */
            PreparedStatement ps = conn.prepareStatement("SELECT * FROM " + TableName);
//        ps.setString(1, TableName);

            /*
            We select the rows and verify the results.
             */
            ResultSet rs = ps.executeQuery();

            String Line = "";
            for (int i = 1; i < rs.getMetaData().getColumnCount() + 1; i++) {
                Line = Line + "   " + rs.getMetaData().getColumnName(i);
            }

            showtableOutput = Line;
            while (rs.next()) {
                Line = "";
                for (int i = 1; i < rs.getMetaData().getColumnCount() + 1; i++) {
                    Line = Line + "   " + rs.getString(i);
                }

                showtableOutput = showtableOutput + LS + Line;
                System.out.println(Line);
            }

            rs.close();
            ps.close();
            conn.commit();
            conn.close();

        } catch (Throwable e) {
            System.out.println("exception thrown:");

            if (e instanceof SQLException) {
                printSQLError((SQLException) e);
            } else {
                e.printStackTrace();
            }
        }
        return showtableOutput;

    }

    public String ExecuteQuery(String QueryText) {
        String ExecuteQueryOutput = null;
        try {
            /*
            The connection specifies create=true to cause
            the database to be created. To remove the database,
            remove the directory AttackDB and its contents.
            The directory AttackDB will be created under
            the directory that the system property
            derby.system.home points to, or the current
            directory if derby.system.home is not set.
             */
            if ((conn = setConn()) != null) {
                System.out.println("Connected to database " + getDatabaseName());
            } else {
                throw new Exception("Not connected to database " + getDatabaseName());
            }

            conn.setAutoCommit(false);

            /*
            Creating a statement lets us issue commands against
            the connection.
             */
            PreparedStatement ps = conn.prepareStatement(QueryText);

            /*
            We select the rows and verify the results.
             */
            ResultSet rs = ps.executeQuery();

            String Line = "";
            for (int i = 1; i < rs.getMetaData().getColumnCount() + 1; i++) {
                Line = Line + "   " + rs.getMetaData().getColumnName(i);
            }

            ExecuteQueryOutput = Line;
            while (rs.next()) {
                Line = "";
                for (int i = 1; i < rs.getMetaData().getColumnCount() + 1; i++) {
                    Line = Line + "   " + rs.getString(i);
                }

                ExecuteQueryOutput = ExecuteQueryOutput + LS + Line;
                System.out.println(Line);
            }

            rs.close();
            ps.close();
            conn.commit();
            conn.close();

        } catch (Throwable e) {
            System.out.println("exception thrown:");

            if (e instanceof SQLException) {
                printSQLError((SQLException) e);
            } else {
                e.printStackTrace();
            }
        }
        return ExecuteQueryOutput;

    }

    public void DeleteResults(String TargetPHPFileSelectedComboBox) {
        PreparedStatement ps = null;
        int count = 0;
        ResultSet rs = null;

        // Adapted from http://developers.sun.com/docs/javadb/10.2.2/ref/rrefclob.html
        try {
            if ((conn = setConn()) != null) {
                System.out.println("Connected to database " + getDatabaseName());
            } else {
                throw new Exception("Not connected to database " + getDatabaseName());
            }

            conn.setAutoCommit(false);

            // Test to see if the Target PHP file is already in the DB
            ps = conn.prepareStatement("SELECT COUNT(*) FROM TARGET_PHP_FILES WHERE PATH=?");
            ps.setString(1, TargetPHPFileSelectedComboBox);

            rs = ps.executeQuery(); // get the result

            rs.next();
            count = rs.getInt(1);
            rs.close();
            ps.close();

            if (count != 0) {// The file already exists in the DB

                int n = 0;
                n = JOptionPane.showConfirmDialog(new JFrame(), "Do you want to delete the results of the injection in\n" + TargetPHPFileSelectedComboBox + "?", "Attention!", JOptionPane.ERROR_MESSAGE, JOptionPane.YES_NO_OPTION);
                if (n == JOptionPane.YES_OPTION) {//updates the file

                    // Clean previous vulnerability injections in the same file
                    System.out.println(TargetPHPFileSelectedComboBox);
                    ps = conn.prepareStatement("DELETE FROM VULNERABILITY_INJECTION_RESULTS WHERE ID IN (SELECT VULNERABILITY_INJECTION_RESULTS.ID FROM VULNERABILITY_INJECTION_RESULTS, TARGET_PHP_FILES WHERE TARGET_PHP_FILE=TARGET_PHP_FILES.ID AND TARGET_PHP_FILES.PATH=?)");
                    ps.setString(1, TargetPHPFileSelectedComboBox);
                    ps.execute();
                    conn.commit();
                    rs.close();
                }
            }
            conn.commit();
            ps.close();
            conn.close();

        } catch (Throwable e) {
            System.out.println("exception thrown:");

            if (e instanceof SQLException) {
                printSQLError((SQLException) e);
            } else {
                e.printStackTrace();
            }
        }
    }

    public void printSQLError(SQLException e) {
        while (e != null) {
            System.out.println(e.toString());
            e = e.getNextException();
        }
    }
}
