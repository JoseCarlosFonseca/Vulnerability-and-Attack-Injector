/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package attackinjector;

import java.net.*;
import java.io.*;
import java.sql.*;

/**
 *
 * @author ze
 */
public class SQLInjectionAttack {
    // attack config
    String method = "GET";
    String HTTPRequest = null;
    static final String[] grepStrings = new String[]{
        "error", "exception", "illegal", "invalid", "not found", "xsstest"
    };
    static final String[] extractStrings = new String[]{
        "<td>Name:</td><td>", "<td>Address:</td><td>"
    };

    SQLInjectionAttack() {
    }

    public String setHTTPRequest(String host, String url) {
        // build parameters
        StringBuffer GETParameters = new StringBuffer();
        StringBuffer COOKIEParameters = new StringBuffer();
        StringBuffer POSTParamenters = new StringBuffer();
        /*
        for (int i = 0; i < params.length; i++) {
        String value = (i == currentParam) ? payloads.getPayload() : params[i].value;
        
        if (params[i].type == Param.Type.URL) {
        GETParameters.append(params[i].name + "=" + value + "&");
        }
        if (params[i].type == Param.Type.COOKIE) {
        COOKIEParameters.append(params[i].name + "=" + value + "; ");
        }
        if (params[i].type == Param.Type.BODY) {
        POSTParamenters.append(params[i].name + "=" + value + "&");
        }
        }
         */
        // build request
        StringBuffer req = new StringBuffer();
        req.append(method + " " + url);
        if (GETParameters.length() > 0) {
            req.append("?" + GETParameters.substring(0, GETParameters.length() - 1));
        }
        req.append(" HTTP/1.0\r\nHost: " + host);
        if (COOKIEParameters.length() > 0) {
            req.append("\r\nCookie: " + COOKIEParameters.toString());
        }
        if (POSTParamenters.length() > 0) {
            req.append("\r\nContent-Type: application/x-www-form-urlencoded");
            req.append("\r\nContent-Length: " + (POSTParamenters.length() - 1));
            req.append("\r\n\r\n");
            req.append(POSTParamenters.substring(0, POSTParamenters.length() - 1));
        } else {
            req.append("\r\n\r\n");
        }
        return req.toString();
    }

    String getHTTPResponse(String req, String host, int port) throws UnknownHostException, IOException {
        Socket socket = new Socket(host, port);
        OutputStream os = socket.getOutputStream();
        os.write(req.getBytes());
        os.flush();

        BufferedReader br = new BufferedReader(new InputStreamReader(
                socket.getInputStream()));
        StringBuffer response = new StringBuffer();
        String line;
        while (null != (line = br.readLine())) {
            response.append(line);
        }
        os.close();
        br.close();
        return response.toString();
    }

    String parseResponse(String response) {
        StringBuffer output = new StringBuffer();

        output.append(response.split("\\s+", 3)[1] + "\t");
        output.append(Integer.toString(response.length()) + "\t");

        for (String grep : grepStrings) {
            if (response.indexOf(grep) != -1) {
                output.append(grep + "\t");
            }
        }
        for (String extract : extractStrings) {
            int from = response.indexOf(extract);
            if (from == -1) {
                continue;
            }
            from += extract.length();
            int to = response.indexOf("<", from);
            if (to == -1) {
                to = response.length();
            }
            output.append(response.subSequence(from, to) + "\t");
        }

        return output.toString();
    }

    public int getMaxID(DatabaseAccess JavaDBAccess) {

        Connection conn = null;
        PreparedStatement ps = null;
        ResultSet rs = null;
        int TARGET_PHP_FILES_RUNS_FUNCTIONS_ID = 0;
        try {
            if ((conn = JavaDBAccess.setConn()) != null) {
                System.out.println("Connected to database " + JavaDBAccess.getDatabaseName());
            } else {
                throw new Exception("Not connected to database " + JavaDBAccess.getDatabaseName());
            }

            conn.setAutoCommit(false);

            // Start a transaction by inserting a record in the TARGET_PHP_FILES_FUNCTIONS table
            ps = conn.prepareStatement("SELECT MAX(ID) FROM TARGET_PHP_FILES_RUNS_FUNCTIONS");
            rs = ps.executeQuery(); // get the result
            rs.next();
            TARGET_PHP_FILES_RUNS_FUNCTIONS_ID = rs.getInt(1);
            rs.close();
            ps.close();
            conn.commit();
            conn.close();
        } catch (Throwable e) {
            System.out.println("exception thrown:");

            if (e instanceof SQLException) {
                JavaDBAccess.printSQLError((SQLException) e);
            } else {
                e.printStackTrace();
            }
        }
        return TARGET_PHP_FILES_RUNS_FUNCTIONS_ID;
    }

    public String getRequestText(DatabaseAccess JavaDBAccess, int TARGET_PHP_FILES_RUNS_FUNCTIONS_ID) {
        String request = "";
        Connection conn = null;
        PreparedStatement ps = null;
        ResultSet rs = null;
        String host = "";
        try {
            if ((conn = JavaDBAccess.setConn()) != null) {
                System.out.println("Connected to database " + JavaDBAccess.getDatabaseName());
            } else {
                throw new Exception("Not connected to database " + JavaDBAccess.getDatabaseName());
            }

            conn.setAutoCommit(false);

            // Start a transaction by inserting a record in the TARGET_PHP_FILES_FUNCTIONS table
            ps = conn.prepareStatement("SELECT HTTP_REQUEST_HEADER,HTTP_REQUEST_POST FROM TARGET_PHP_FILES_RUNS_FUNCTIONS WHERE ID=?");
            ps.setInt(1, TARGET_PHP_FILES_RUNS_FUNCTIONS_ID);
            rs = ps.executeQuery(); // get the result
            rs.next();
            request = rs.getString(1) + rs.getString(2);
            rs.close();
            ps.close();
            conn.commit();
            conn.close();
        } catch (Throwable e) {
            System.out.println("exception thrown:");

            if (e instanceof SQLException) {
                JavaDBAccess.printSQLError((SQLException) e);
            } else {
                e.printStackTrace();
            }
        }
        return request;
    }

    public String getRequestHost(DatabaseAccess JavaDBAccess, int TARGET_PHP_FILES_RUNS_FUNCTIONS_ID) {
        Connection conn = null;
        PreparedStatement ps = null;
        ResultSet rs = null;
        String host = "";
        try {
            if ((conn = JavaDBAccess.setConn()) != null) {
                System.out.println("Connected to database " + JavaDBAccess.getDatabaseName());
            } else {
                throw new Exception("Not connected to database " + JavaDBAccess.getDatabaseName());
            }

            conn.setAutoCommit(false);

            // Start a transaction by inserting a record in the TARGET_PHP_FILES_FUNCTIONS table
            ps = conn.prepareStatement("SELECT HTTP_REQUEST_HOST FROM TARGET_PHP_FILES_RUNS_FUNCTIONS WHERE ID=?");
            ps.setInt(1, TARGET_PHP_FILES_RUNS_FUNCTIONS_ID);
            rs = ps.executeQuery(); // get the result
            rs.next();
            host = rs.getString(1);
            rs.close();
            ps.close();
            conn.commit();
            conn.close();
        } catch (Throwable e) {
            System.out.println("exception thrown:");

            if (e instanceof SQLException) {
                JavaDBAccess.printSQLError((SQLException) e);
            } else {
                e.printStackTrace();
            }
        }
        return host;
    }

    String issueRequest(String req, String host, int port) throws UnknownHostException, IOException {
        int pos = -1;
        int contentLength = 0;
        int byteCount = 0;
        boolean waitForDisconnect = true;

        req=req.trim()+"\r\n\r\n"; // to avoid hang of the program because of missing "\r\n\r\n" at the end of the request
        Socket socket = new Socket(host, port);
        OutputStream os = socket.getOutputStream();
        os.write(req.getBytes());
        os.flush();


        BufferedInputStream br = new BufferedInputStream(socket.getInputStream());

        StringBuffer response = new StringBuffer();
        String data;
        while (null != (data = readLine(br))) {
            // the header ends at the first blank line
            if (data.length() == 0) {
                break;
            }
            // check for the Content-Length header
            pos = data.toLowerCase().indexOf("content-length:");
            if (pos >= 0) {
                contentLength = Integer.parseInt(data.substring(pos + 15).trim());
            }
            response.append(data + "\r\n");
        }
        response.append(data + "\r\n");

        if (contentLength > 0) {
            waitForDisconnect = false;
        }
        if ((contentLength > 0) || (waitForDisconnect)) {
            try {
                byte[] buf = new byte[4096];
                int bytesIn = 0;
                while (((byteCount < contentLength) || (waitForDisconnect)) && ((bytesIn = br.read(buf)) >= 0)) {
                    byteCount += bytesIn;
                    String line = new String(buf, 0, bytesIn);
                    response.append(line);
                }

            } catch (Exception e) {
                String errMsg = "Error getting HTTP body: " + e;
                System.out.println(errMsg);
            }
        }

        os.close();
        br.close();
        return response.toString();
    }

    private String readLine(InputStream in) {
        // reads a line of text from an InputStream
        StringBuffer data = new StringBuffer("");
        int c;

        try {
            // if we have nothing to read, just return null
            in.mark(1);
            if (in.read() == -1) {
                return null;
            } else {
                in.reset();
            }
            while ((c = in.read()) >= 0) {
                // check for an end-of-line character
                if ((c == 0) || (c == 10) || (c == 13)) {
                    break;
                } else {
                    data.append((char) c);
                }
            }

            // deal with the case where the end-of-line terminator is \r\n
            if (c == 13) {
                in.mark(1);
                if (in.read() != 10) {
                    in.reset();
                }
            }
        } catch (Exception e) {
            String errMsg = "Error getting header: " + e;
            System.out.println(errMsg);
        }

        // and return what we have
        return data.toString();
    }
}
