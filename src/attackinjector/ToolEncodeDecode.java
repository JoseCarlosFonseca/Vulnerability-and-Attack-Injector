/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package attackinjector;

import java.security.*;
import java.io.*;

/**
 *
 * @author ze
 */
public class ToolEncodeDecode {

    /*
     * 
     * Handles all of the encoding and decoding functions for the application.
     *
     * This file is part of CAL9000 
     *
     * CAL9000 Web Application Security Testing Assistant, Version 2.0
     * Copyright (C) 2006 Christopher Loomis
     *
     * Distributed under the GNU General Public License
     *
     * CAL9000 is free software; you can redistribute it and/or modify it
     * under the terms of the GNU General Public License as published by the Free 
     * Software Foundation; either version 2 of the License, or (at your option) 
     * any later version.
     * 
     * CAL9000 is distributed in the hope that it will be useful, but WITHOUT 
     * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
     * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
     *
     * You should have received a copy of the GNU General Public License along with 
     * CAL9000; if not, write to the Free Software Foundation, Inc., 51 Franklin 
     * Street, Fifth Floor, Boston, MA 02110-1301 USA
     *
     * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
     * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
     * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
     * DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
     * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
     * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
     * OF THE POSSIBILITY OF SUCH DAMAGE.
     *
     * See http://www.digilantesecurity.com/CAL9000/index.html for more info.
     * You may direct email inquiries to cal9000tool at mac.com
     *
     * Thanks to Ben Ramsey (http://md5.benramsey.com) for the MD5 server-side decode file.
     * Thanks to Mateusz Turcza (mturcza at tlen dot pl) for IE Selected Text Coordinates function.
     *
     */

    /*
     * Main driver for encoding functions. Takes plaintext, encoding type, trailing character, delimiter
     *  as inputs. Determines which encoding function to use and returns encoded text.
     */
    public String Encode(String source, Boolean uppercase, String postchars, String EncodeMethodText) {
        String encType = "";
        String plainText = "";
        String DecodeTextResult = "";

        try {
            plainText = source;

            // Checks encoding type and routes request to proper function.
            if (plainText.length() > 0) {
//                System.out.println(EncodeMethodText);
                if (EncodeMethodText.compareTo("Base 64") == 0) {
                    DecodeTextResult = encodeString(plainText);
                } else if (EncodeMethodText.compareTo("Hex") == 0) {
                    DecodeTextResult = plainToUrl(plainText, false, null, "Hex");
                } else if (EncodeMethodText.compareTo("HTTP") == 0) {
                    DecodeTextResult = plainToUrl(plainText, false, null, "HTTP");
                } else if (EncodeMethodText.compareTo("HTTP (full)") == 0) {
                    DecodeTextResult = plainToUrl(plainText, false, null, "HTTP (full)");
                } else if (EncodeMethodText.compareTo("MD5") == 0) {
                    //from: http://www.spiration.co.uk/post/1199
                    byte[] defaultBytes = plainText.getBytes();
                    try {
                        MessageDigest algorithm = MessageDigest.getInstance("MD5");
                        algorithm.reset();
                        algorithm.update(defaultBytes);
                        byte messageDigest[] = algorithm.digest();

                        StringBuffer hexString = new StringBuffer();
                        for (int i = 0; i < messageDigest.length; i++) {
                            hexString.append(Integer.toHexString(0xFF & messageDigest[i]));
                        }
                        String foo = messageDigest.toString();
                        DecodeTextResult = hexString + "";
                    } catch (NoSuchAlgorithmException nsae) {
                    }
                } else if (EncodeMethodText.compareTo("SHA1") == 0) {
                    DecodeTextResult = SHA1(plainText);
                } else if (EncodeMethodText.compareTo("Unicode") == 0) {
                    DecodeTextResult = plainToUnicode(plainText, false, "");
                } else if (EncodeMethodText.compareTo("HTML (simple)") == 0) {
//                    DecodeTextResult = plainToHTML(plainText);
                    DecodeTextResult = escapeHTML(plainText);
                } else {
                    System.out.println("Invalid encoding type " + encType);
                }
                return DecodeTextResult;
            } else {
                System.out.println("Paste or type text here to encode");
            }

        } catch (Exception e) {
            System.out.println(e);
        }
        return "";
    }

    /*
     * Main driver for decoding functions. Takes encoded text and decoding type as inputs
     * and returns plain text.
     */
    public String Decode(String source, Boolean uppercase, String postchars, String DecodeMethodText) {

        String encType = "";
        String encodedText = "";
        String EncodeTextResult = "";

        try {
            encodedText = source;

            // Checks encoding type and routes request to proper function.
            if (encodedText.length() > 0) {
//                System.out.println(DecodeMethodText);
                if (DecodeMethodText.compareTo("Base 64") == 0) {
                    EncodeTextResult = decodeString(encodedText);
                } else if (DecodeMethodText.compareTo("Hex") == 0) {
                    EncodeTextResult = decodeHTTP(encodedText, "", true);
                } else if (DecodeMethodText.compareTo("HTTP") == 0) {
                    EncodeTextResult = decodeHTTP(encodedText, "", false);
                } else if (DecodeMethodText.compareTo("HTTP (full)") == 0) {
                    EncodeTextResult = decodeHTTP(encodedText, "", false);
                } else if (DecodeMethodText.compareTo("MD5") == 0) {
                    System.out.println("MD5 decoding not suported ");
                } else if (DecodeMethodText.compareTo("SHA1") == 0) {
                    System.out.println("SHA1 decoding not suported ");
                } else if (DecodeMethodText.compareTo("Unicode") == 0) {
                    EncodeTextResult = unicodeToPlain(encodedText, false, "");
                } else if (DecodeMethodText.compareTo("HTML (simple)") == 0) {
//                    EncodeTextResult = HTMLToPlain(encodedText);
                    EncodeTextResult = unescapeHTML(encodedText,0);
                } else {
                    System.out.println("Invalid encoding type " + encType);
                }
                return EncodeTextResult;
            } else {
                System.out.println("Paste or type text here to encode");
            }

        } catch (Exception e) {
            System.out.println(e);
        }
        return "";
    }

    /*
     * Converts encodedText to URL Encoded text. Will leave letters, numbers and some
     * special characters intact and hex encode all others. Note that the reserved and
     * syntax characters are not encoded regardless of context. Restricted to ASCII.
     */
    private String plainToUrl(String source, Boolean uppercase, String postchars, String Method) {
        String urlReg = "[a-zA-Z0-9$_.+!*~(),&/:;=?@#-']";
        Integer inLength = 0;
        String urlResult = "";
        Boolean invalidChar = false;

        Integer srcLen = source.length();
        String hex = "";

        // Cycle through each input character.
        if (srcLen > 0) {

            for (int i = 0; i < srcLen; i++) {
                inLength = Integer.toString(source.charAt(i), 16).length();

                // Leave character as is.
                if ((source.substring(i, i + 1).matches(urlReg)) && (Method.compareTo("HTTP") == 0)) {
                    urlResult += source.charAt(i);

                // Encode all other ASCII characters.
                } else if (source.charAt(i) < 128) {
                    hex = Integer.toHexString(source.charAt(i));
                    if (postchars != null) {
                        hex = hex + postchars;
                    }

                    if (uppercase) {
                        hex = hex.toUpperCase();
                    }
                    if (Method.compareTo("Hex") != 0) {
                        // Pad with zero for results < 10.
                        if (inLength == 1) {
                            urlResult += "%0" + hex;
                        } else if (inLength == 2) {
                            urlResult += "%" + hex;
                        }
                    } else {
                        urlResult += hex;
                    }
                } else {
                    urlResult += (" [" + source.charAt(i) + " Not Valid] ");
                    invalidChar = true;
                }
            }
        }

        // Message to indicated invalid character.
        if (invalidChar) {
            System.out.println("Attempting to encode Invalid Character");

            invalidChar = false;
        }

        return urlResult;
    }

    // from: http://www.anyexample.com/programming/java/java_simple_class_to_compute_sha_1_hash.xml
    private static String convertToHex(byte[] data) {
        StringBuffer buf = new StringBuffer();
        for (int i = 0; i < data.length; i++) {
            int halfbyte = (data[i] >>> 4) & 0x0F;
            int two_halfs = 0;
            do {
                if ((0 <= halfbyte) && (halfbyte <= 9)) {
                    buf.append((char) ('0' + halfbyte));
                } else {
                    buf.append((char) ('a' + (halfbyte - 10)));
                }
                halfbyte = data[i] & 0x0F;
            } while (two_halfs++ < 1);
        }
        return buf.toString();
    }

    private static String SHA1(String text)
            throws NoSuchAlgorithmException, UnsupportedEncodingException {
        MessageDigest md;
        md = MessageDigest.getInstance("SHA-1");
        byte[] sha1hash = new byte[40];
        md.update(text.getBytes("iso-8859-1"), 0, text.length());
        sha1hash = md.digest();
        return convertToHex(sha1hash);
    }
    //from: http://www.source-code.biz/snippets/java/Base64Coder.java.txt
    /**
     * A Base64 Encoder/Decoder.
     *
     * <p>
     * This class is used to encode and decode data in Base64 format as described in RFC 1521.
     *
     * <p>
     * This is "Open Source" software and released under the <a href="http://www.gnu.org/licenses/lgpl.html">GNU/LGPL</a> license.<br>
     * It is provided "as is" without warranty of any kind.<br>
     * Copyright 2003: Christian d'Heureuse, Inventec Informatik AG, Switzerland.<br>
     * Home page: <a href="http://www.source-code.biz">www.source-code.biz</a><br>
     *
     * <p>
     * Version history:<br>
     * 2003-07-22 Christian d'Heureuse (chdh): Module created.<br>
     * 2005-08-11 chdh: Lincense changed from GPL to LGPL.<br>
     * 2006-11-21 chdh:<br>
     *  &nbsp; Method encode(String) renamed to encodeString(String).<br>
     *  &nbsp; Method decode(String) renamed to decodeString(String).<br>
     *  &nbsp; New method encode(byte[],int) added.<br>
     *  &nbsp; New method decode(String) added.<br>
     */

// Mapping table from 6-bit nibbles to Base64 characters.
    private static char[] map1 = new char[64];

    static {
        int i = 0;
        for (char c = 'A'; c <= 'Z'; c++) {
            map1[i++] = c;
        }
        for (char c = 'a'; c <= 'z'; c++) {
            map1[i++] = c;
        }
        for (char c = '0'; c <= '9'; c++) {
            map1[i++] = c;
        }
        map1[i++] = '+';
        map1[i++] = '/';
    }

// Mapping table from Base64 characters to 6-bit nibbles.
    private static byte[] map2 = new byte[128];

    static {
        for (int i = 0; i < map2.length; i++) {
            map2[i] = -1;
        }
        for (int i = 0; i < 64; i++) {
            map2[map1[i]] = (byte) i;
        }
    }

    /**
     * Encodes a string into Base64 format.
     * No blanks or line breaks are inserted.
     * @param s  a String to be encoded.
     * @return   A String with the Base64 encoded data.
     */
    private static String encodeString(String s) {
        return new String(encode(s.getBytes()));
    }

    /**
     * Encodes a byte array into Base64 format.
     * No blanks or line breaks are inserted.
     * @param in  an array containing the data bytes to be encoded.
     * @return    A character array with the Base64 encoded data.
     */
    private static char[] encode(byte[] in) {
        return encode(in, in.length);
    }

    /**
     * Encodes a byte array into Base64 format.
     * No blanks or line breaks are inserted.
     * @param in   an array containing the data bytes to be encoded.
     * @param iLen number of bytes to process in <code>in</code>.
     * @return     A character array with the Base64 encoded data.
     */
    private static char[] encode(byte[] in, int iLen) {
        int oDataLen = (iLen * 4 + 2) / 3;       // output length without padding
        int oLen = ((iLen + 2) / 3) * 4;         // output length including padding
        char[] out = new char[oLen];
        int ip = 0;
        int op = 0;
        while (ip < iLen) {
            int i0 = in[ip++] & 0xff;
            int i1 = ip < iLen ? in[ip++] & 0xff : 0;
            int i2 = ip < iLen ? in[ip++] & 0xff : 0;
            int o0 = i0 >>> 2;
            int o1 = ((i0 & 3) << 4) | (i1 >>> 4);
            int o2 = ((i1 & 0xf) << 2) | (i2 >>> 6);
            int o3 = i2 & 0x3F;
            out[op++] = map1[o0];
            out[op++] = map1[o1];
            out[op] = op < oDataLen ? map1[o2] : '=';
            op++;
            out[op] = op < oDataLen ? map1[o3] : '=';
            op++;
        }
        return out;
    }

    /**
     * Decodes a string from Base64 format.
     * @param s  a Base64 String to be decoded.
     * @return   A String containing the decoded data.
     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.
     */
    private static String decodeString(String s) {
        return new String(decode(s));
    }

    /**
     * Decodes a byte array from Base64 format.
     * @param s  a Base64 String to be decoded.
     * @return   An array containing the decoded data bytes.
     * @throws   IllegalArgumentException if the input is not valid Base64 encoded data.
     */
    private static byte[] decode(String s) {
        return decode(s.toCharArray());
    }

    /**
     * Decodes a byte array from Base64 format.
     * No blanks or line breaks are allowed within the Base64 encoded data.
     * @param in  a character array containing the Base64 encoded data.
     * @return    An array containing the decoded data bytes.
     * @throws    IllegalArgumentException if the input is not valid Base64 encoded data.
     */
    private static byte[] decode(char[] in) {
        int iLen = in.length;
        if (iLen % 4 != 0) {
            throw new IllegalArgumentException("Length of Base64 encoded input string is not a multiple of 4.");
        }
        while (iLen > 0 && in[iLen - 1] == '=') {
            iLen--;
        }
        int oLen = (iLen * 3) / 4;
        byte[] out = new byte[oLen];
        int ip = 0;
        int op = 0;
        while (ip < iLen) {
            int i0 = in[ip++];
            int i1 = in[ip++];
            int i2 = ip < iLen ? in[ip++] : 'A';
            int i3 = ip < iLen ? in[ip++] : 'A';
            if (i0 > 127 || i1 > 127 || i2 > 127 || i3 > 127) {
                throw new IllegalArgumentException("Illegal character in Base64 encoded data.");
            }
            int b0 = map2[i0];
            int b1 = map2[i1];
            int b2 = map2[i2];
            int b3 = map2[i3];
            if (b0 < 0 || b1 < 0 || b2 < 0 || b3 < 0) {
                throw new IllegalArgumentException("Illegal character in Base64 encoded data.");
            }
            int o0 = (b0 << 2) | (b1 >>> 4);
            int o1 = ((b1 & 0xf) << 4) | (b2 >>> 2);
            int o2 = ((b2 & 3) << 6) | b3;
            out[op++] = (byte) o0;
            if (op < oLen) {
                out[op++] = (byte) o1;
            }
            if (op < oLen) {
                out[op++] = (byte) o2;
            }
        }
        return out;
    }

    /*
     * Converts encodedText to Unicode Encoded text. No restrictions. 
     */
    private String plainToUnicode(String source, Boolean uppercase, String postchars) {

        Integer inLength = 0;
        String prechars = "%u";
        String uniTemp = "";
        String uniResult = "";
        String strResult = "";

        Integer srcLen = source.length();
        String hex = "";

        // Cycle through each input character.
        if (srcLen > 0) {

            for (int i = 0; i < srcLen; i++) {
                inLength = Integer.toString(source.charAt(i), 16).length();

                if (inLength > 0) {
                    uniTemp = Integer.toHexString(source.charAt(i));

                    if (uppercase) {
                        prechars = prechars.toUpperCase();
                        uniTemp = uniTemp.toUpperCase();
                    }

                    if (inLength == 1) {
                        uniResult += prechars + "000" + uniTemp + postchars; // + delimiter;
                    } else if (inLength == 2) {
                        uniResult += prechars + "00" + uniTemp + postchars; // + delimiter;
                    } else if (inLength == 3) {
                        uniResult += prechars + "0" + uniTemp + postchars; // + delimiter;
                    } else if (inLength >= 4) {
                        uniResult += prechars + uniTemp + postchars; // + delimiter;
                    } else {
                        uniResult += " [" + source.charAt(i) + " Not Valid] "; // + delimiter;
                    }

                } else {
                    uniResult += " [" + source.charAt(i) + " Not Valid] "; // + delimiter;
                }
            }

            strResult = uniResult;

        }
        return strResult;
    }

    /*
     * Converts plainText to Unicode Encoded text. No restrictions. 
     */
    private String plainToHTML(String source) {
        String strResult = "";
        String sourceText = "";

        Integer srcLen = source.length();

        // Cycle through each input character.
        if (srcLen > 0) {

            for (int i = 0; i < srcLen; i++) {
                sourceText = source.substring(i, i + 1);
                if (sourceText.compareTo("<") == 0) {
                    strResult += "&lt;";
                } else if (sourceText.compareTo(">") == 0) {
                    strResult += "&gt;";
                } else if (sourceText.compareTo("'") == 0) {
                    strResult += "&apos;";
                } else if (sourceText.compareTo("\"") == 0) {
                    strResult += "&quot;";
                } else if (sourceText.compareTo("&") == 0) {
                    strResult += "&amp;";
                } else {
                    strResult += source.substring(i, i + 1);
                }
            }
        }

        return strResult;
    }

    /*
     * Converts URL Encoded text to encodedText.
     */
    private String decodeHTTP(String source, String postchars, boolean Hex) {
        String plainResult = "";

        Integer srcLen = source.length();
        String hex = "";

        // Cycles through encoded text. Finds all instances of %XX and converts them
        // to the plain text equivalent.
        if (srcLen > 0) {

            for (int i = 0; i < srcLen; i++) {
                // Trailing characters present.
                if (postchars.length() > 0) {
                    if ((source.charAt(i) == '%') || (Hex)) {
                        if (Hex) {
                            hex = source.substring(i, i + 1) + source.substring(i + 1, i + 2);
                            i = i + 1 + postchars.length();
                        } else {
                            hex = source.substring(i + 1, i + 2) + source.substring(i + 2, i + 3);
                            i = i + 2 + postchars.length();
                        }
                        plainResult += unescape(hex);
                    } else if(source.charAt(i) == '+'){//The + sign is converted to a space
                        plainResult += " ";
                    }else{
                        plainResult += source.charAt(i);
                    }
                // No trailing characters present.
                } else {
                    if ((source.charAt(i) == '%') || (Hex)) {
                        if (Hex) {
                            hex = source.substring(i, i + 1) + source.substring(i + 1, i + 2);
                            i = i + 1;
                        } else {
                            hex = source.substring(i + 1, i + 2) + source.substring(i + 2, i + 3);
                            i = i + 2;
                        }
                        plainResult += unescape(hex);
                    } else if(source.charAt(i) == '+'){//The + sign is converted to a space
                        plainResult += " ";
                    } else {
                        plainResult += source.charAt(i);
                    }
                }
            }
        }
        return plainResult;
    }

    private String unescape(String source) {
        String unescapeText = "";
        int i;
        char ch;

        i = Integer.parseInt(source, 16);

        ch = (char) i;
        unescapeText = ch + "";
        return unescapeText;
    }
    //from: http://www.rgagnon.com/javadetails/java-0307.html
    //Complete list: http://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Character_entities_in_HTML
    private static String[][] htmlEscape =
            {{"&apos;", "'"},{"&lt;", "<"}, {"&gt;", ">"},
        {"&amp;", "&"}, {"&quot;", "\""},
        {"&agrave;", "à"}, {"&Agrave;", "À"},
        {"&acirc;", "â"}, {"&auml;", "ä"},
        {"&Auml;", "Ä"}, {"&Acirc;", "Â"},
        {"&aring;", "å"}, {"&Aring;", "Å"},
        {"&aelig;", "æ"}, {"&AElig;", "Æ"},
        {"&ccedil;", "ç"}, {"&Ccedil;", "Ç"},
        {"&eacute;", "é"}, {"&Eacute;", "É"},
        {"&egrave;", "è"}, {"&Egrave;", "È"},
        {"&ecirc;", "ê"}, {"&Ecirc;", "Ê"},
        {"&euml;", "ë"}, {"&Euml;", "Ë"},
        {"&iuml;", "ï"}, {"&Iuml;", "Ï"},
        {"&ocirc;", "ô"}, {"&Ocirc;", "Ô"},
        {"&ouml;", "ö"}, {"&Ouml;", "Ö"},
        {"&oslash;", "ø"}, {"&Oslash;", "Ø"},
        {"&szlig;", "ß"}, {"&ugrave;", "ù"},
        {"&Ugrave;", "Ù"}, {"&ucirc;", "û"},
        {"&Ucirc;", "Û"}, {"&uuml;", "ü"},
        {"&Uuml;", "Ü"}, {"&nbsp;", " "},
        {"&copy;", "\u00a9"},
        {"&reg;", "\u00ae"},
        {"&euro;", "\u20a0"}};

    private static final String unescapeHTML(String s, int start) {
        int i, j, k, l;

        i = s.indexOf("&", start);
        start = i + 1;
        if (i > -1) {
            j = s.indexOf(";", i);
            /*
            we don't want to start from the beginning
            the next time, to handle the case of the &
            thanks to Pieter Hertogh for the bug fix!
             */
            if (j > i) {
                // ok this is not most optimized way to
                // do it, a StringBuffer would be better,
                // this is left as an exercise to the reader!
                String temp = s.substring(i, j + 1);
                // search in htmlEscape[][] if temp is there
                k = 0;
                while (k < htmlEscape.length) {
                    if (htmlEscape[k][0].equals(temp)) {
                        break;
                    } else {
                        k++;
                    }
                }
                if (k < htmlEscape.length) {
                    s = s.substring(0, i) + htmlEscape[k][1] + s.substring(j + 1);
                    return unescapeHTML(s, start); // recursive call
                }
            }
        }
        return s;
    }

    /*
     * Converts plainText to Unicode Encoded text. No restrictions. 
     */
    private String escapeHTML(String source) {
        String strResult = "";
        String sourceText = "";
        int k;

        Integer srcLen = source.length();

        // Cycle through each input character.
        if (srcLen > 0) {

            for (int i = 0; i < srcLen; i++) {
                sourceText = source.substring(i, i + 1);
                // search in htmlEscape[][] if sourceText is there
                k = 0;
                while (k < htmlEscape.length) {
                    if (htmlEscape[k][1].equals(sourceText)) {
                        break;
                    } else {
                        k++;
                    }
                }
                if (k < htmlEscape.length) {
                    strResult += htmlEscape[k][0];
                } else {
                    strResult += source.substring(i, i + 1);
                }
            }
        }

        return strResult;
    }

    /*
     * Converts encodedText to Unicode Encoded text. No restrictions. 
     */
    private String unicodeToPlain(String source, Boolean uppercase, String postchars) {
        String plainResult = "";

        Integer srcLen = source.length();
        String hex = "";
        int j;

        // Cycles through encoded text. Finds all instances of %XX and converts them
        // to the plain text equivalent.
        if (srcLen > 0) {

            for (int i = 0; i < srcLen; i++) {
                // Trailing characters present.
                if (postchars.length() > 0) {
                    if (source.charAt(i) == '%') {
                        hex = source.substring(i + 1, i + 2) + source.substring(i + 2, i + 3);
                        i = i + 2 + postchars.length();
                        plainResult += unescape(hex);
                    } else {
                        plainResult += source.charAt(i);
                    }
                // No trailing characters present.
                } else {
                    if (source.charAt(i) == '%') {
                        j = i + 2;
                        hex = "";
                        while ((source.charAt(j) != '%') && (j < srcLen - 1)) {
                            hex += source.substring(j, j + 1);
                            j++;
                        }
                        if (j == srcLen - 1) {
                            hex += source.substring(j, j + 1);
                            j++;
                        }
                        i = j - 1;
                        plainResult += unescape(hex);
                    } else {
                        plainResult += source.charAt(i);
                    }
                }
            }
        }
        return plainResult;
    }

    /*
     * Converts encodedText to Unicode Encoded text. No restrictions. 
     */
    private String HTMLToPlain(String source) {
        String strResult = "";
        String sourceText = "";
        String hex = "";
        int j;

        Integer srcLen = source.length();

        // Cycle through each input character.
        if (srcLen > 0) {

            for (int i = 0; i < srcLen; i++) {
                hex = "";
                sourceText = source.substring(i, i + 1);
                if (sourceText.compareTo("&") == 0) {
                    j = i + 1;
                    while ((source.substring(j, j + 1).compareTo(";") != 0) && (j < srcLen - 1)) {
                        j++;
                    }
                    hex = source.substring(i, j + 1);
                    i = j;
                }
                if (hex.compareTo("&lt;") == 0) {
                    strResult += "<";
                } else if (hex.compareTo("&gt;") == 0) {
                    strResult += ">";
                } else if (hex.compareTo("&apos;") == 0) {
                    strResult += "'";
                } else if (hex.compareTo("&quot;") == 0) {
                    strResult += "\"";
                } else if (hex.compareTo("&amp;") == 0) {
                    strResult += "&";
                } else {
                    strResult += source.substring(i, i + 1);
                }
            }
        }

        return strResult;
    }
}
